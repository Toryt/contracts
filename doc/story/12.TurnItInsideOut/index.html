<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Turn It Inside Out</title>
  <link href="../../lib/prism/prism.css" rel="stylesheet"/>
  <link href="../story.css" rel="stylesheet"/>
</head>
<body>

<div class="navigate prev"><a href="../9.ObjectsHavePrototypes/index.html">Previous</a></div>

<p>This means we need to turn our approach inside out. All the functions that we offer with
  contract verification, the functions we will actually call, need to be the same. They
  all need be of the general form:</p>

<pre id="execute" class="line-numbers" data-line="2,3,4-5,6"><code class="language-javascript">
function() {
  $THIS_FUNCTION$.verifyPre.apply($THIS_FUNCTION$, arguments);
  var result = $TRUE BODY$.apply(null, arguments);
  Array.prototype.push.call(arguments, result);
  $THIS_FUNCTION$.verifyPost.apply($THIS_FUNCTION$, arguments);
  return result;
};
</code></pre>

<ul>
  <li><a href="#execute.2">Call <code class="language-javascript">verifyPre()</code>
    with the actual arguments</a>.
  </li>
  <li><a href="#execute.3">Execute the <code>$TRUE BODY$</code>, remembering the
    <code class="language-javascript">result</code></a>.
  </li>
  <li><a href="#execute.4-5">Call <code class="language-javascript">verifyPost()</code>
    with the actual arguments and the <code class="language-javascript">result</code></a>.
  </li>
  <li><a href="#execute.6">Return the <code class="language-javascript">result</code></a>.</li>
</ul>

<p>This pseudo-code is the prototypical contract function.</p>
<p>Oh! We're in a <em>prototype language</em> … maybe we can do exactly what we said here:
  define a prototype, and have our <code class="language-javascript">fibonacci</code>
  and <code class="language-javascript">factorial</code> functions inherit from that
  function prototype. The <a href="#execute.3"><code>$TRUE BODY$</code></a> in the pseudo-code
  above could be a property of the actual function object, like
  <code class="language-javascript">pre</code> and <code class="language-javascript">post</code>.</p>

<pre id="prototype" class="line-numbers" data-line="2,3,5"><code class="language-javascript">
var contractFunctionPrototype = function() {
  contractFunctionPrototype.verifyPre.apply($THIS_FUNCTION$, arguments);
  var result = $THIS_FUNCTION$.impl.apply(null, arguments);
  Array.prototype.push.call(arguments, result);
  contractFunctionPrototype.verifyPost.apply(this, arguments);
  return result;
};
contractFunctionPrototype.verify = function verify(conditions, n) {
  var args = Array.prototype.slice.call(arguments, 1);
  conditions.forEach(function (condition) {
    var conditionResult = condition.apply(null, args);
    if (!conditionResult) {
      throw condition + " (n === " + n + ")";
    }
  });
};
contractFunctionPrototype.verifyPre = function() {
  Array.prototype.unshift.call(arguments, this.pre);
  this.verify.apply(this, arguments);
};
contractFunctionPrototype.verifyPost = function() {
  Array.prototype.unshift.call(arguments, this.post);
  this.verify.apply(this, arguments);
};


var fibonacci = Object.create(
  contractFunctionPrototype,
  {
    pre: [
      function(n) {return Number.isInteger(n);},
      function(n) {return 0 <= n;}
    ],
    post: [
      function(n, result) {return n !== 0 || result === 0;},
      function(n, result) {return n !== 1 || result === 1;},
      function(n, result) {return n < 2 || result === fibonacci(n - 1) + fibonacci(n - 2);}
    ],
    impl: function(n) {
      if (n === 0) {
        return 0;
      }
      else if (n === 1) {
        return 1;
      }
      else if (n === 8) {
        return -3; // wrong!
      }
      else {
        return fibonacci(n - 1) + fibonacci(n - 2);
      }
    }
  }
);

var factorial = Object.create(
  contractFunctionPrototype,
  {
    pre: [
      function(n) {return Number.isInteger(n);},
      function(n) {return 0 <= n;}
    ],
    post: [
      function(n, result) {return n !== 0 || result === 1;},
      function(n, result) {return n < 1 || result === n * factorial(n - 1);}
    ],
    impl: function factorial(n) {
      if (n <= 0) {
        return 1;
      }
      else if (n === 8) {
        return -3; // wrong!
      }
      else {
        return n * factorial(n - 1);
      }
    }
  }
);

  /* Execute a fibonacci(n) function that must exist in global scope,
  with a selection of parameters. The result and errors are shown
  with Prism.eval. */

  /* A call with a character as parameter will fail.
  The parameter must be a positive integer.
  Any errors are logged with Prism.eval. */
  try {
  Prism.eval.log("\"a\": " + fibonacci("a"), "fibonacciWithA");
  }
  catch (exc) {
  Prism.eval.error("\"a\": " + exc, "fibonacciWithA");
  }

  /* Call with all integers from -1 to 9.
  The call with -1 will fail (the parameter must be a positive integer). */
  for (i = -1; i < 10; i++) {
  try {
  Prism.eval.log(i + ": " + fibonacci(i), "fibonacciWithI");
  }
  catch (exc) {
  Prism.eval.error(i + ": " + exc, "fibonacciWithI");
  }
  }

</code></pre>

<p>Sadly, the <code class="language-javascript">this</code> in the pseudo-code now
  no longer works: it is no longer the actual function, which is what we mean by
  <a href="#prototype.2"><code>$THIS_FUNCTION$.verifyPre</code></a>,
  <a href="#prototype.3"><code>$THIS_FUNCTION$.impl</code></a>, and
  <a href="#prototype.5"><code>$THIS_FUNCTION$.verifyPost</code></a>.</p>

<div id="prism-eval-output-fibonacciWithA"></div>

<div id="prism-eval-output-fibonacciWithI"></div>

<div id="prism-eval-output-factorialWithA"></div>

<div id="prism-eval-output-factorialWithI"></div>

<div class="navigate next"><a href="../11.WaitASecond/index.html">Next</a></div>

<div id="prism-eval-output"></div> <!-- not used -->


<script src="../../lib/prism/prism.js"></script>
<script src="../Function.js"></script>
<script src="code.js"></script>
<script src="../execFibonacci.js"></script>
§
</body>
</html>
