<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Turn It Inside Out</title>
  <link href="../../lib/prism/prism.css" rel="stylesheet"/>
  <link href="../story.css" rel="stylesheet"/>
</head>
<body>

<div class="navigate prev"><a href="../9.ObjectsHavePrototypes/index.html">Previous</a></div>

<img src="ContractFunctionAttempt.svg" style="width: 100%;"/>

<p>Let's try to build this structure, and verify that everithing is as expected.</p>

<h1>Objects</h1>

<h2><code class="language-javascript">Object.prototype</code></h2>

<p><code class="language-javascript" data-eval="true">Object.prototype</code> is the
  prototypical object, the end of all prototype chains. Its has no prototype itself:
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(Object.prototype)</code>.</p>
<p>Like any object, it has a constructor:
  <code class="language-javascript" data-eval="true">Object.prototype.constructor === Object</code>.</p>

<h2><code class="language-javascript">Object</code> constructor</h2>

<p><code class="language-javascript" data-eval="true">Object</code> is a constructor function.
  Its prototype is
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(Object) === Function.prototype</code>,
  the prototypical <code class="language-javascript">Function</code>.</p>
<p>Because it is also an object,
  if has a constructor:
  <code class="language-javascript" data-eval="true">Object.constructor</code>.
  But that is in fact just inherited from the prototype:
  <code class="language-javascript" data-eval="true">Object.hasOwnProperty("constructor")</code>,
  whereas
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(Object).hasOwnProperty("constructor")</code>.</p>
<p>Because it is a
  constructor itself, it has a prototype property:
  <code class="language-javascript" data-eval="true">Object.prototype</code>,
  which we discussed already.</p>

<h2>A simple object</h2>

<p>A simple object <code class="language-javascript" data-eval="true">aSimpleObject = {};</code>
  has the prototypical object as prototype
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(aSimpleObject) === Object.prototype;</code>.</p>
<p>Its constructor is
  <code class="language-javascript" data-eval="true">aSimpleObject.constructor === Object</code>.
  But that is in fact just inherited from the prototype:
  <code class="language-javascript" data-eval="true">aSimpleObject.hasOwnProperty("constructor")</code>,
  whereas <code class="language-javascript" data-eval="true">Object.getPrototypeOf(aSimpleObject).hasOwnProperty
    ("constructor")</code>.</p>



<h1>Functions</h1>

<h2><code class="language-javascript">Function.prototype</code></h2>

<p><code class="language-javascript" data-eval="true">Function.prototype</code> is
  the prototypical <code class="language-javascript">Function</code>.</p>
<p>As it is itself an object,
  it has the prototypical object as prototype:
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(Function.prototype) ===
    Object.prototype</code>.</p>
<p>Because it is a function, it's constructor is
  <code class="language-javascript" data-eval="true">Function.prototype.constructor === Function</code>.</p>

<h2><code class="language-javascript">Function</code> constructor</h2>

<p><code class="language-javascript" data-eval="true">Function</code> is a constructor function itself.
  Its prototype is
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(Function) === Function.prototype</code>,
  because it is a function, and its
  <code class="language-javascript" data-eval="true">Function.constructor</code> is a self-reference:
  <code class="language-javascript" data-eval="true">Function.constructor === Function</code>.</p>

<h2>A simple function</h2>

<p>A simple function <code class="language-javascript" data-eval="true">aSimpleFunction = function() {};</code>
  has the prototypical function as prototype
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(aSimpleFunction) ===
    Function.prototype;</code>.<p>
<p>Its constructor is
  <code class="language-javascript" data-eval="true">aSimpleFunction.constructor === Function</code>.
  But that is again inherited from the prototype:
  <code class="language-javascript" data-eval="true">aSimpleFunction.hasOwnProperty("constructor")</code>,
  whereas
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(aSimpleFunction).hasOwnProperty("constructor")</code>.</p>



<h1>Contract functions</h1>

<h2>Contract function prototype</h2>

<p>A contract function prototype should have
  <code class="language-javascript">Function.prototype</code> as its prototype, and have a default
  <code class="language-javascript">pre</code>, <code class="language-javascript">post</code>, and
  <code class="language-javascript">impl</code> property. Let's skip the
  constructor for a
  moment.</p>

<pre data-eval="true"><code class="language-javascript">
contractFunctionPrototype = function() {
  Prism.eval.log("contractFunctionPrototype executed");
  return "contractFunctionPrototype execution result";
};
contractFunctionPrototype.pre = [];
contractFunctionPrototype.post = [];
contractFunctionPrototype.impl = undefined;
</code></pre>


<p>That works:
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(contractFunctionPrototype)
    === Function.prototype</code>,
  <code class="language-javascript" data-eval="true">Object.keys(contractFunctionPrototype)</code>.</p>

<pre data-eval="true"><code class="language-javascript">
Object.keys(contractFunctionPrototype).forEach(function(key) {
  var value = contractFunctionPrototype[key];
  if (value instanceof Array) {
    value = "[" + value.join(", ") + "]";
  }
  Prism.eval.log("contractFunctionPrototype." + key + ": " + value);
});
</code></pre>

<p><code class="language-javascript">contractFunctionPrototype</code> is executable:
  <code class="language-javascript" data-eval="true">contractFunctionPrototype()</code>.</p>

<h2>Contract function instance</h2>

<p>Can we now create a function instance that is executable, and has
  <code class="language-javascript">contractFunctionPrototype</code> as prototype?
  Since we do not have a constructor yet, first we need to decide what kind of thing to start from.</p>


<h3>Attempt 1</h3>

<p>Let's try with a function:</p>

<pre data-eval="true"><code class="language-javascript">
contractFunctionInstance1 = function() {
  Prism.eval.log("contractFunctionInstance1 executed");
  return "contractFunctionInstance1 execution result";
};
Object.setPrototypeOf(contractFunctionInstance1, contractFunctionPrototype);
</code></pre>

<p>(MDN warns about the use of <code class="language-javascript">setPrototypeOf</code>, but disregard that for the
  moment.)</p>

<p>This looks good:
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(contractFunctionInstance1) ===
    contractFunctionPrototype</code>. It has no own properties
  (<code class="language-javascript" data-eval="true">Object.keys(contractFunctionInstance1).length</code>),
  and is executable:
  <code class="language-javascript" data-eval="true">contractFunctionInstance1()</code>.</p>

<p>Sadly, this is not the execution of <code class="language-javascript">contractFunctionPrototype</code>.
  Can we do that at all, inherit the body of a function?</p>

<h3>Attempt 2</h3>

<p>Can we do it with a
  <code class="language-javascript">Function</code> constructor call?</p>

<pre data-eval="true"><code class="language-javascript">
contractFunctionInstance2 = new Function();
Object.setPrototypeOf(contractFunctionInstance2, contractFunctionPrototype);
</code></pre>

<p>This looks good:
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(contractFunctionInstance2) ===
    contractFunctionPrototype</code>. It has no own properties
  (<code class="language-javascript" data-eval="true">Object.keys(contractFunctionInstance2).length</code>),
  and is executable:
  <code class="language-javascript" data-eval="true">contractFunctionInstance2()</code>.</p>

<p>Again, we get the execution of the instance (nop). Bummer.</p>

<h3>Attempt 3</h3>

<p>What if we don't start we a function to begin with, but with an object?</p>

<pre data-eval="true"><code class="language-javascript">
contractFunctionInstance3 = {};
contractFunctionInstance3 instanceof Function
</code></pre>

<p>Now, set the prototype:</p>

<pre data-eval="true"><code class="language-javascript">
Object.setPrototypeOf(contractFunctionInstance3, contractFunctionPrototype);
</code></pre>

<p>That is surprising! A type error! Yet someting did happen:
  <code class="language-javascript" data-eval="true">contractFunctionInstance3 instanceof Function</code>.
  <code class="language-javascript">instanceof</code> is equivalent to
  <code class="language-javascript" data-eval="true">contractFunctionInstance3.constructor === Function</code>,
  and that property is inherited in 2 steps:
  <code class="language-javascript" data-eval="true">contractFunctionInstance3.hasOwnProperty("constructor")</code>,
  and
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(contractFunctionInstance3).hasOwnProperty("constructor")</code>,
  yet
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(Object.getPrototypeOf(contractFunctionInstance3)).hasOwnProperty("constructor")</code>.
  The setting of the prototype did work:
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(contractFunctionInstance3) ===
    contractFunctionPrototype</code>!
  (Actually, <code class="language-javascript">instanceof</code> is equivalent to
    <code class="language-javascript" data-eval="true">Function.prototype ===
      Object.getPrototypeOf(Object.getPrototypeOf(contractFunctionInstance3))</code>, or,
  , more general:</p>

<pre data-eval="true"><code class="language-javascript">
(function io(Constructor, obj) {
  return obj ? Constructor.prototype === obj || io(Constructor, Object.getPrototypeOf(obj)) : false;
}(Function, contractFunctionInstance3))</code></pre>

<p>In Chrome the error message is cryptic. It says:</p>

<pre>TypeError: Type error</pre>

<p>Firefox makes clear what the error is:</p>

<pre>TypeError: Function.prototype.toString called on incompatible object</pre>

<p><code class="language-javascript">Object.setPrototypeOf</code> returns the object it works on.
  When trying to visualize the result of the execution, we implicitly call
  <code class="language-javascript">toString</code>, which is overridden for
  <code class="language-javascript">Function</code> to return the text of the implementation …
  and <code class="language-javascript">contractFunctionInstance3</code> doesn't have that:
  <code class="language-javascript" data-eval="true">contractFunctionInstance3.toString()</code>.
  Firefox has another method to try this:
  <code class="language-javascript" data-eval="true">contractFunctionInstance3.toSource()</code>
  (in other browsers, this doesn't work).</p>

<p>This is a function:
  <code class="language-javascript" data-eval="true">contractFunctionInstance3 instanceof Function</code>,
  and it looks good:
  <code class="language-javascript" data-eval="true">Object.getPrototypeOf(contractFunctionInstance3) ===
    contractFunctionPrototype</code>. It has no own properties
  (<code class="language-javascript" data-eval="true">Object.keys(contractFunctionInstance3).length</code>).
  But it is  not executable:
  <code class="language-javascript" data-eval="true">contractFunctionInstance3()</code>.</p>

<p>Firefox says:</p>

<pre>TypeError: contractFunctionInstance3 is not a function</pre>

<p>In Chrome, the error message might reveal something:</p>

<pre>TypeError: contractFunctionInstance3 is not a function. (In 'contractFunctionInstance3()', 'contractFunctionInstance3' is an instance of Function)</pre>

<p>The message says it is <em>an instance of
  <code class="language-javascript">Function</code></em> (with capital <strong>F</strong>), but it is <em>not a
  <strong>f</strong>unction</em>.</p>

<p>Look: <code class="language-javascript" data-eval="true">typeof contractFunctionInstance3</code>,
  where <code class="language-javascript" data-eval="true">typeof contractFunctionInstance2</code>,
  <code class="language-javascript" data-eval="true">typeof contractFunctionInstance1</code>,
  and <code class="language-javascript" data-eval="true">typeof contractFunctionPrototype</code>.
  This makes clear that there is a big difference between <code class="language-javascript">instanceof</code>
  and <code class="language-javascript">typeof</code>. Only things with
  <code class="language-javascript">typeof x === "function"</code> are executable in JavaScript.
  And the <code class="language-javascript">typeof</code> cannot be manipulated …</p>

<div class="navigate next"><a href="../11.WaitASecond/index.html">Next</a></div>

<script src="../../lib/prism/prism.js"></script>
</body>
</html>
